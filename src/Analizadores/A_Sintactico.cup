package Analizadores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.io.File; // Import the File class
import java.io.FileNotFoundException; // Import this class to handle errors
import java.util.Scanner; // Import the Scanner class to read text files
import java.io.FileWriter; // Import the FileWriter class
import java.io.IOException;

parser code
{:
    public String resultado="";
    public static String nombreArchivo;
    public FileWriter myWriter;
    public int contador = 0;
    public SimboloFuncion sFuncion;
    public int offsetParam = 4;
    public boolean retornEncontrado = false;
    public boolean returnEnDeclaracion = false;

    // lista donde se almacenan los errores sintácticos
    public static LinkedList<TError> TablaES = new LinkedList<TError>();
    public static LinkedList<ErrorSemantico> erroresSemanticos = new LinkedList<ErrorSemantico>();
    public static LinkedList<Integer> listaParametros = new LinkedList<Integer>();
    public static LinkedList<RegistroSemantico> pilaSemantica = new LinkedList<RegistroSemantico>();
    public static LinkedList<Simbolo> tablaSimbolos = new LinkedList<Simbolo>();
    public static boolean errorEncontrado = false;

    public void writeLine(final String pData, final int flag) throws IOException {
        if (flag == 0) {
            myWriter.write(pData + "\n");
        } else {
            myWriter.write(pData + " ");
        }
        myWriter.flush();
    }


    //Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {        
        if(s.value != null){
            String lexema = s.value.toString();
            int fila = s.left;
            int columna = s.right;
            TError datos = new TError(lexema,fila,columna,"Error Sintactico","Caracter no esperado");
            TablaES.add(datos);
            System.out.println("------ Recuperacion exitosa ------");
            System.out.println("\t\tLexema: "+lexema);
        }
        errorEncontrado = true;
    }

    //Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        if(s.value != null){
            String lexema = s.value.toString();
            int fila = s.left;
            int columna = s.right;
            TError datos = new TError(lexema,fila,columna,"Error Sintactico","Caracter no esperado");
            TablaES.add(datos);
            System.out.println("------ Error Sintactico irrecuperable ------");
            System.out.println("\t\tLexema: "+lexema);
        }
        errorEncontrado = true;
    }

    /* Metodos para realizar las acciones semánticas*/

    public void recuerdoTipo(String pTipo, int lineaPos){
        pilaSemantica.push(new RS_Tipo(pTipo));
    }

    public void recuerdoAccess(String pAcces, int lineaPos){
        if(pAcces != null){
            pilaSemantica.push(new RS_ACCESS(pAcces));
        }
    }

    public void recuerdoID(String pIdent, int lineaPos){
        pilaSemantica.push(new RS_IDENT(pIdent));
    }

    // Ya se agregaron los errores
    public void insertarTablaSimbolos(int lineaPos){

        RS_IDENT id = (RS_IDENT)pilaSemantica.pop();
        RegistroSemantico sig = pilaSemantica.pop();
        SimboloVariable var = new SimboloVariable();
        if (sig.valueType == RegistroSemantico.Value.TIPO){
            RS_Tipo tipo = (RS_Tipo) sig;
            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = "public";
            var.tipoVariable = tipo.tipo;
        } else {
            RS_ACCESS acc = (RS_ACCESS) sig;
            RS_Tipo tipo = (RS_Tipo)pilaSemantica.pop();

            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = acc.access;
            var.tipoVariable = tipo.tipo;
        }
        //var.printDatos();
        // verificar si ya el id esta en la pila
        boolean estaEnTabla = false;
        for(Simbolo sim : tablaSimbolos){
            if(sim.nombre.equals(var.nombre)){
                // Variable ya esta definida dar error
                //System.out.println("Ya esta en la tabla");
                String msg = "La variable '";
                msg = msg.concat(id.ident);
                msg = msg.concat("' ya se encuentra definida");
                erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                estaEnTabla = true;
                errorEncontrado = true;
            }
        }

        if(estaEnTabla){
            // Agregar el error donde corresponde
        } else {
            tablaSimbolos.push(var);
        }

    }

    // Ya se agregaron los errores
    public void insertarTablaSimbolosAsignacion(int lineaPos){

        RS_IDENT id = (RS_IDENT)pilaSemantica.pop();
        RegistroSemantico sig = pilaSemantica.pop();
        SimboloVariable var = new SimboloVariable();

        if (sig.valueType == RegistroSemantico.Value.TIPO){
            RS_Tipo tipo = (RS_Tipo) sig;
            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = "public";
            var.tipoVariable = tipo.tipo;
        } else {
            RS_ACCESS acc = (RS_ACCESS) sig;
            RS_Tipo tipo = (RS_Tipo)pilaSemantica.pop();

            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = acc.access;
            var.tipoVariable = tipo.tipo;
        }
        //var.printDatos();
        // verificar si ya el id esta en la pila
        boolean estaEnTabla = false;
        for(Simbolo sim : tablaSimbolos){
            if(sim.nombre.equals(var.nombre)){
                // Variable ya esta definida dar error
                //System.out.println("Ya esta en la tabla");
                String msg = "La variable '";
                msg = msg.concat(id.ident);
                msg = msg.concat("' ya se encuentra definida");
                erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                estaEnTabla = true;
                errorEncontrado = true;
            }
        }

        if(estaEnTabla){
            // Agregar el error donde corresponde
        } else {
            tablaSimbolos.push(var);
        }

    }

    public void recuerdaConstante(String pConst, String pTipo, int lineaPos){
        RS_DO dop = new RS_DO(pTipo, pConst);
        pilaSemantica.push(dop);
    }

    public void recuerdaVariable(String pConst, int lineaPos){
        RS_DO dop = new RS_DO("variable", pConst);
        pilaSemantica.push(dop);
    }

    public void recuerdaOperador(String pOperador, int lineaPos){
        RS_Operador op = new RS_Operador(pOperador);
        pilaSemantica.push(op);
    }

    // Ya se agregaron los errores pero revisar la linea que muestra cuando es una expresion booleana
    public void evalBinary(int lineaPos){

        RS_DO do_uno = (RS_DO) pilaSemantica.pop();
        RS_Operador do_op = (RS_Operador) pilaSemantica.pop();
        // El RS siguiente se obtiene después para evitar problemas de tipo
        // en caso de que el operador se igual ya que a la izq del igual
        // viene un RS_IDENT y no un RS_DO

        // validar do_uno, puede ser una variable o constante
        if(do_uno.tipo.equals("variable")){
            boolean seEncontro = false;
            for(Simbolo s : tablaSimbolos){
                if(s.nombre.equals(do_uno.valor)){
                    // no hay error
                    seEncontro = true;
                }
            }
            if(!seEncontro){
                // dar error
                if(!do_uno.valor.equals("eax")){

                    String msg = "La variable '";
                    msg = msg.concat(do_uno.valor);
                    msg = msg.concat("' no se encuentra definida");
                    erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                    // agregar la variable a la tabla de simbolos
                    SimboloVariable sv = new SimboloVariable();
                    sv.nombre = do_uno.valor;
                    sv.tipoSimbolo = "error";
                    tablaSimbolos.add(sv);
                }
            }
        }

        if(do_op.operador.equals("=")){
            // verificar que el tipo concuerde en ambos lados
            RegistroSemantico rs = pilaSemantica.pop();
            if(rs instanceof RS_IDENT){
                RS_IDENT do_dos = (RS_IDENT) rs;
                // mov dword [b], 5
                String codMov = "mov dword [";
                codMov = codMov.concat(do_dos.ident);
                codMov = codMov.concat("], ");
                codMov = codMov.concat(do_uno.valor);
                try{
                    writeLine(codMov, 0);
                } catch(IOException e){
                    e.printStackTrace();
                }

                pilaSemantica.push(do_dos);
                // dejar un RS_IDENT en la pila
            } else {
                RS_DO do_dos = (RS_DO) rs;
                // mov dword [b], 5
                String codMov = "mov dword [";
                codMov = codMov.concat(do_dos.valor);
                codMov = codMov.concat("], ");
                codMov = codMov.concat(do_uno.valor);
                try{
                    writeLine(codMov, 0);
                } catch(IOException e){
                    e.printStackTrace();
                }

                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }

            }

            // Generar un DO
            // hacer push del DO
        } else if(do_op.operador.equals("+")){

            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String resultado = String.valueOf(Integer.parseInt(do_uno.valor) + Integer.parseInt(do_dos.valor));
                RS_DO newDO = new RS_DO("constante_numerico", resultado);
                pilaSemantica.push(newDO);
            } else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("constante_numerico")){
                try{
                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_uno.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "add eax, ";
                    codResta = codResta.concat(do_dos.valor);
                    writeLine(codResta, 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }


                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);

            } else if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("variable")){
                try{
                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_dos.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "add eax, ";
                    codResta = codResta.concat(do_uno.valor);
                    writeLine(codResta, 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }
                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);
            } else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("variable")){
                try{
                    // push ebx
                    writeLine("push ebx", 0);

                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_uno.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // mov ebx, dword [var2]
                    codMov = "mov ebx, dword [";
                    codMov = codMov.concat(do_dos.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "add eax, ebx";
                    writeLine(codResta, 0);

                    writeLine("pop ebx", 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }

                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);
            }else{
                // generar codigo asm de la operacion
                //Crear un registro DO
            }
            // Generar un DO
            // hacer push del DO
        } else if(do_op.operador.equals("-")){
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String resultado = String.valueOf(Integer.parseInt(do_dos.valor) - Integer.parseInt(do_uno.valor));
                RS_DO newDO = new RS_DO("constante_numerico", resultado);
                pilaSemantica.push(newDO);
            } else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("constante_numerico")){
                try{
                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_uno.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "sub eax, ";
                    codResta = codResta.concat(do_dos.valor);
                    writeLine(codResta, 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }
                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);

            } else if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("variable")){
                try{
                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_dos.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "sub eax, ";
                    codResta = codResta.concat(do_uno.valor);
                    writeLine(codResta, 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }
                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);
            } else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("variable")){
                try{
                    // push ebx
                    writeLine("push ebx", 0);

                    // mov eax, dword [var]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(do_uno.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // mov ebx, dword [var2]
                    codMov = "mov ebx, dword [";
                    codMov = codMov.concat(do_dos.valor);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, num
                    String codResta = "sub eax, ebx";
                    writeLine(codResta, 0);

                    writeLine("pop ebx", 0);

                } catch (IOException e ){
                    e.printStackTrace();
                }
                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                // hago DO, variable, eax
                RS_DO newDO = new RS_DO("variable", "eax");
                pilaSemantica.push(newDO);
            }else{
                // generar codigo asm de la operacion
                //Crear un registro DO
            }
            // Generar un DO
            // hacer push del DO
        } else if (do_op.operador.equals("<") || do_op.operador.equals("<=") || do_op.operador.equals(">") || do_op.operador.equals(">=") || do_op.operador.equals("==") || do_op.operador.equals("!=")) {
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String op = do_op.operador;

                try{

                    String codComparacion = "cmp ";
                    codComparacion = codComparacion.concat(do_uno.valor);
                    codComparacion = codComparacion.concat(", ");
                    codComparacion = codComparacion.concat(do_dos.valor);
                    writeLine(codComparacion, 0);
                    
                    String codCmp = "";
                    switch(op){
                        case "<":
                        writeLine("jl", 1);
                            break;
                        case "<=":
                        writeLine("jle", 1);
                            break;
                        case ">":
                        writeLine("jg", 1);
                            break;
                        case ">=":
                        writeLine("jge", 1);
                            break;
                        case "==":
                        writeLine("je", 1);
                            break;
                        case "!=":
                        writeLine("jne", 1);
                            break;
                    }
                } catch(IOException e){
                    e.printStackTrace();
                }
            }
            else if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("variable")){
                // generar codigo asm de la operacion
                String nombreVar = do_dos.valor;
                int operando = Integer.parseInt(do_uno.valor);
                String op = do_op.operador;

                try{
                    // Para preservar eax
                    writeLine("push eax", 0);

                    // mov eax, dword [nombreVar]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(nombreVar);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    String codResta = "sub eax, ";
                    codResta = codResta.concat(do_uno.valor);
                    writeLine(codResta, 0);

                    String codComparacion = "cmp eax, ";
                    codComparacion = codComparacion.concat("0");
                    writeLine(codComparacion, 0);

                    writeLine("pop eax", 0);
                    
                    String codCmp = "";
                    switch(op){
                        case "<":
                        writeLine("jl", 1);
                            break;
                        case "<=":
                        writeLine("jle", 1);
                            break;
                        case ">":
                        writeLine("jg", 1);
                            break;
                        case ">=":
                        writeLine("jge", 1);
                            break;
                        case "==":
                        writeLine("je", 1);
                            break;
                        case "!=":
                        writeLine("jne", 1);
                            break;
                    }
                } catch(IOException e){
                    e.printStackTrace();
                }
                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                //Crear un registro DO
            }
            else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("constante_numerico")){
                // generar codigo asm de la operacion
                String nombreVar = do_uno.valor;
                // int operando = Integer.parseInt(do_dos.valor);
                String op = do_op.operador;

                try{
                    // push eax
                    writeLine("push eax", 0);

                    // mov eax, dword [nombreVar]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(nombreVar);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub eax, valor
                    String codResta = "sub eax, ";
                    codResta = codResta.concat(do_dos.valor);
                    writeLine(codResta, 0);

                    String codComparacion = "cmp eax, ";
                    codComparacion = codComparacion.concat("0");
                    writeLine(codComparacion, 0);
                    
                    writeLine("pop eax", 0);
                    
                    String codCmp = "";
                    switch(op){
                        case "<":
                        writeLine("jl", 1);
                            break;
                        case "<=":
                        writeLine("jle", 1);
                            break;
                        case ">":
                        writeLine("jg", 1);
                            break;
                        case ">=":
                        writeLine("jge", 1);
                            break;
                        case "==":
                        writeLine("je", 1);
                            break;
                        case "!=":
                        writeLine("jne", 1);
                            break;
                    }
                } catch(IOException e){
                    e.printStackTrace();
                }
                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                //Crear un registro DO
            }
            else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("variable")){
                // generar codigo asm de la operacion
                String nombreVarUno = do_uno.valor;
                String nombreVarDos = do_dos.valor;
                // int operando = Integer.parseInt(do_dos.valor);
                String op = do_op.operador;

                try{
                    writeLine("push eax", 0);
                    writeLine("push ebx", 0);

                    // mov eax, dword [nombreVarUno]
                    String codMov = "mov eax, dword [";
                    codMov = codMov.concat(nombreVarUno);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // mov ebx, dword [nombreVarDos]
                    codMov = "mov ebx, dword [";
                    codMov = codMov.concat(nombreVarDos);
                    codMov = codMov.concat("]");
                    writeLine(codMov, 0);

                    // sub ebx, eax
                    String codResta = "sub ebx, eax";
                    writeLine(codResta, 0);

                    // cmp dword [nombreDos]
                    String codComparacion = "cmp ebx, 0";
                    writeLine(codComparacion, 0);

                    writeLine("pop ebx", 0);
                    writeLine("pop eax", 0);
                    
                    String codCmp = "";
                    switch(op){
                        case "<":
                        writeLine("jl", 1);
                            break;
                        case "<=":
                        writeLine("jle", 1);
                            break;
                        case ">":
                        writeLine("jg", 1);
                            break;
                        case ">=":
                        writeLine("jge", 1);
                            break;
                        case "==":
                        writeLine("je", 1);
                            break;
                        case "!=":
                        writeLine("jne", 1);
                            break;
                    }
                } catch(IOException e){
                    e.printStackTrace();
                }
                if(!do_uno.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_uno.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_uno.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_uno.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                if(!do_dos.valor.equals("eax")){

                    boolean seEncontro = false;
                    for(Simbolo s : tablaSimbolos){
                        if(s.nombre.equals(do_dos.valor)){
                            seEncontro = true;
                        }
                    }
                    if(!seEncontro){

                        String msg = "La variable '";
                        msg = msg.concat(do_dos.valor);
                        msg = msg.concat("' no se encuentra definida");
                        erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
                        // agregar la variable a la tabla de simbolos
                        SimboloVariable sv = new SimboloVariable();
                        sv.nombre = do_dos.valor;
                        sv.tipoSimbolo = "error";
                        tablaSimbolos.add(sv);
                        errorEncontrado = true;
                    }
                }
                //Crear un registro DO
            }

        } else {
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            // Generar un DO
            // hacer push del DO
        }
    }

    public void startIf(){
        try{
            writeLine(";----------IF---------", 0);
        } catch(IOException e ){
            e.printStackTrace();
        }
        String elseLabel = "Else_label_";
        elseLabel = elseLabel.concat(String.valueOf(contador));

        String exitLabel = "Exit_label_";
        exitLabel = exitLabel.concat(String.valueOf(contador));

        RS_IF new_IF = new RS_IF(elseLabel, exitLabel);

        contador++;
        pilaSemantica.push(new_IF);
    }

    public void testIf(){
        RS_IF rs = (RS_IF) pilaSemantica.pop();

        String elseLabel = rs.else_label;
        try{
            writeLine(elseLabel, 0);
        } catch(IOException e){
            e.printStackTrace();
        }
        pilaSemantica.push(rs);
    }

    public void startElse(){
        RS_IF rs = (RS_IF) pilaSemantica.pop();
        String exitLabel = rs.exit_label;
        String elseLabel = rs.else_label;
        try{
            // jump exitLabel
            writeLine("jmp", 1);
            writeLine(exitLabel, 0);
            // elseLabel:
            writeLine(elseLabel, 1);
            writeLine(":", 0);
        } catch(IOException e){
            e.printStackTrace();
        }
        pilaSemantica.push(rs);
        
    }

    public void endIf(){
        RS_IF rs = (RS_IF) pilaSemantica.pop();
        String exitLabel = rs.exit_label;
        try{
            // exitlabel:
            writeLine(exitLabel, 1);
            writeLine(":", 0);
            writeLine(";-------Fin if-------", 0);
        } catch(IOException e){
            e.printStackTrace();
        }
    }

    public void startWhile(){
        String WhileLabel = "While_label_";
        WhileLabel = WhileLabel.concat(String.valueOf(contador));

        String exitLabel = "While_exit_label_";
        exitLabel = exitLabel.concat(String.valueOf(contador));

        RS_WHILE new_while = new RS_WHILE(WhileLabel, exitLabel);

        try{
            writeLine(";----------While---------", 0);
            writeLine(WhileLabel, 1);
            writeLine(":", 0);
            
        } catch(IOException e ){
            e.printStackTrace();
        }

        contador++;
        pilaSemantica.push(new_while);
    }

    public void testWhile(){
        RS_WHILE rs = (RS_WHILE) pilaSemantica.pop();

        String whileExitLabel = rs.exit_label;
        try{
            writeLine(whileExitLabel, 0);
        } catch(IOException e){
            e.printStackTrace();
        }
        pilaSemantica.push(rs);
    }

    public void endWhile(){
        RS_WHILE rs = (RS_WHILE) pilaSemantica.pop();

        String whileExitLabel = rs.exit_label;
        String whileLabel = rs.while_label;
        try{
            writeLine("jmp", 1);
            writeLine(whileLabel, 0);
            writeLine(whileExitLabel, 1);
            writeLine(":", 0);
            writeLine(";---------Fin While---------", 0);
        } catch(IOException e){
            e.printStackTrace();
        }
    }

    public void finArchivo(){
        try{
            // poner el codigo de finalizacion

            writeLine("mov eax, 1", 0);
            writeLine("xor ebx, ebx", 0);
            writeLine("int 80h", 0);
            writeLine("", 0);

            // escribir el segmento de datos no inicializados
            writeLine("SECTION .bss", 0);
            for(Simbolo s : tablaSimbolos){
                
                if(s.tipoSimbolo.equals("variable")){
                    SimboloVariable var = (SimboloVariable) s;
                    writeLine(var.nombre, 1);
                    writeLine("resb", 1);
                    String tipo = var.tipoVariable;
                    switch(tipo){
                        case "int": 
                            writeLine("4", 0);
                            break;
                        case "string": 
                            writeLine("2", 0);
                            break;
                        case "uint":
                            writeLine("4", 0);
                            break;
                        case "bytes":
                            writeLine("1", 0);
                            break;
                        case "bytes1":
                            writeLine("1", 0);
                            break;
                        case "bytes2":
                            writeLine("2", 0);
                            break;
                        case "bytes3":
                            writeLine("3", 0);
                            break;

                        default:
                            break;
                    }
                }
            }
        } catch(IOException e ){
            e.printStackTrace();
        }
    }

    public void inicioArchivo(){
        try{
            writeLine("SECTION .text", 0);
            writeLine("global main", 0);
            writeLine("main:", 0);
        } catch(IOException e){
            e.printStackTrace();
        }
    }

    public void funcStart(){
        sFuncion = new SimboloFuncion();
    }
    public void recuerdaFuncId(String pId, int lineaPos){
        try{
            sFuncion.nombre = pId;
            writeLine(";----------Inicio funcion------------", 0);
            writeLine(pId, 1);
            writeLine(":", 0);
            writeLine("push ebp", 0);
            writeLine("mov ebp, esp", 0);
            writeLine("sub esp, 0", 0);
        } catch(IOException e){
            e.printStackTrace();
        }
    }
    public void recuerdaTipoParam(String pTipo){
        RS_Tipo rsTipo = new RS_Tipo(pTipo);
        pilaSemantica.push(rsTipo);
    }
    public void recuerdaIdentParam(String pIdent, int lineaPos){
        RS_Tipo rsTipo = (RS_Tipo) pilaSemantica.pop();
        ParametroFuncion pf = new ParametroFuncion(rsTipo.tipo, pIdent, String.valueOf(offsetParam));

        // revisar si el parametro ya fue definido
        boolean seEncontro = false;
        for (ParametroFuncion p : sFuncion.listaParametros){
            if(p.nombre.equals(pIdent)){
                seEncontro = true;
            }
        }
        if(seEncontro){
            // error ya se definio
            String msg = "El parámetro '";
            msg = msg.concat(pIdent);
            msg = msg.concat("' ya se encuentra definido");
            erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
            errorEncontrado = true;
        }

        sFuncion.listaParametros.add(pf);

        switch(rsTipo.tipo){
            case "int": 
                offsetParam += 4;
                break;
            case "string": 
                offsetParam += 4;
                break;
            case "uint":
                offsetParam += 4;
                break;
            case "bytes":
                offsetParam += 1;
                break;
            case "bytes1":
                offsetParam += 1;
                break;
            case "bytes2":
                offsetParam += 2;
                break;
            case "bytes3":
                offsetParam += 3;
                break;

            default:
                break;
        }
    }
    public void recuerdaFuncMod(String pMod){
        if(pMod != null){
            sFuncion.acceso = pMod;
        } else {
            sFuncion.acceso = "public";
        }
    }
    public void recuerdaTipoReturn(String pTipo){
        RS_Tipo rsTipo = new RS_Tipo(pTipo);
        pilaSemantica.push(rsTipo);
    }
    public void recuerdaIdentReturn(String pIdent, int lineaPos){
        RS_Tipo rsTipo = (RS_Tipo) pilaSemantica.pop();
        ParametroFuncion pf = new ParametroFuncion(rsTipo.tipo, pIdent, null);
        sFuncion.retornoVariable = pf;
        returnEnDeclaracion = true;

        boolean seEncontro = false;
        for(Simbolo s : tablaSimbolos){
            if(s.nombre.equals(pIdent)){
                seEncontro = true;
            }
        }
        if(seEncontro){
            String msg = "La variable de retorno '";
            msg = msg.concat(pIdent);
            msg = msg.concat("' ya se encuentra definida");
            erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
            errorEncontrado = true;
        }
    }
    public void retornoFuncion(int lineaPos){
        retornEncontrado = true;
        RS_DO retorno = (RS_DO) pilaSemantica.pop();
        try{
            if(retorno.tipo.equals("constante_numerico")){
                writeLine("mov eax, ", 1);
                writeLine(retorno.valor, 0);
            } else if(retorno.tipo.equals("variable")){
                writeLine("mov eax, dword [", 1);
                writeLine(retorno.valor, 1);
                writeLine("]", 0);

            }
        } catch (IOException e){
            e.printStackTrace();
        }
        RS_DO rsDo = new RS_DO("variable", "eax");
        pilaSemantica.push(rsDo);

    }
    public void funcEnd(int lineaPos){
        try{
            writeLine("mov esp, ebp", 0);
            writeLine("pop ebp", 0);
            writeLine("ret", 0);
            writeLine(";----------Fin funcion------------", 0);
            offsetParam = 4;
            sFuncion = null;
        } catch(IOException e){
            e.printStackTrace();
        }
        // validar que si se indico return en la declaracion, tuve que haber venido en el cuerpo
        if(returnEnDeclaracion == true && retornEncontrado == false){
            //error semántico
            ErrorSemantico err = new ErrorSemantico(lineaPos, "Error en el retorno de la funcion");
            erroresSemanticos.add(err);
            errorEncontrado = true;
        } else if(returnEnDeclaracion == false && retornEncontrado == true){
            ErrorSemantico err = new ErrorSemantico(lineaPos, "Error en el retorno de la funcion");
            erroresSemanticos.add(err);
            errorEncontrado = true;
        }

    }

    public void recordarBreak(String p, int lineaPos){
        // buscar la etiqueta while más proxima
        RS_WHILE rs_w = null;
        for(RegistroSemantico rs: pilaSemantica){
            if(rs.valueType == RegistroSemantico.Value.WHILE){
                rs_w = (RS_WHILE) rs;
                break;
            }
        }
        if(rs_w != null){
            // obtener la etiqueta de exit
            String exitL = rs_w.exit_label;
            try{
                writeLine("jmp", 1);
                writeLine(exitL, 0);
            } catch (IOException e){
                e.printStackTrace();
            }
            // saltar a esa etiqueta
        } else {
            // si no la encuentro dar error semantico
            String msg = "El break no se encuentra dentro de un while";
            erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
            errorEncontrado = true;
        }
    }

    public void recordarContinue(String p, int lineaPos){
        // buscar la etiqueta while más proxima
            // si no la encuentro dar error semantico
        // obtener la etiqueta de inicio del while
        // saltar a esa etiqueta
        // buscar la etiqueta while más proxima
        RS_WHILE rs_w = null;
        for(RegistroSemantico rs: pilaSemantica){
            if(rs.valueType == RegistroSemantico.Value.WHILE){
                rs_w = (RS_WHILE) rs;
                break;
            }
        }
        if(rs_w != null){
            // obtener la etiqueta de exit
            String exitL = rs_w.while_label;
            try{
                writeLine("jmp", 1);
                writeLine(exitL, 0);
            } catch (IOException e){
                e.printStackTrace();
            }
            // saltar a esa etiqueta
        } else {
            // si no la encuentro dar error semantico
            String msg = "El continue no se encuentra dentro de un while";
            erroresSemanticos.add(new ErrorSemantico(lineaPos + 1, msg));
            errorEncontrado = true;
        }

    }

:}

//------> Codigo para las acciones gramaticales
action code
{:
:}

/*--------------- 2da Area: Declaraciones -----------------------*/
//------> declaracion de terminales 
terminal String pragma, solidity, techo, contract, O_Parent_L, C_Parent_L,enumSoli, punto_coma, coma, bool, byteSoli, bytes, uint, uint_O, uint_DS, uint_TD, uint_SC, uint_CVO, uint_DCS, intSoli, int_O, int_DS, int_TD, int_SC, int_CVO, int_DCS, address, address_payable, O_Parent_C, C_Parent_C, publicSoli, privateSoli, igual, trueSoli, falseSoli, igual_igual , mayor_igual , mayor , menor_igual , menor , diferente , op_or , op_and , negacion, mas , menos , div , por , O_Parent_R , C_Parent_R , porcentaje , mas_igual , menos_igual , por_igual , div_igual, punto, thisSoli, whileSoli, returnSoli, breakSoli, continueSoli, forSoli, doSoli, ifSoli, elseSoli, interrogacion_C, punto_punto, structSoli, functionSoli, payableSoli, internalSoli, returns, charss, string, ufixedSoli, ident, numero,numero_HEX,stringSoli, B_I , B_II , B_III , B_IV , B_V , B_VI , B_VII , B_IIX , B_IX , B_X , B_XI , B_XII , B_XIII , B_XIV , B_XV , B_XVI , B_XVII , B_XIIX , B_XIX , B_XX , B_XXI , B_XXII , B_XXIII , B_XXIV , B_XXV , B_XXVI , B_XXVII , B_XXIIX , B_XXIX , B_XXX , B_XXXI , B_XXXII;

//------> declaracion de no terminales
non terminal String INICIO_INICIO, INICIO, BODY_CONTRACT, BODY_CONTRACT_P, BODY_CONTRACT_PP, BODY_CONTRACT_PPP, EN, STRU, FUNC, EN_IDENT, TIPO, VAR_ARR, VAR_ACCESS, VAR_CONTRACT, VAR_CONTRACT_C, EXP, OP_ARIT, OP,OP_BOOL,OP_OP_BOOL, OP_ARIT_P, OP_BOOL_P,FUNC_CALL_PARAMS,FUNC_CALL_PARAMS_P,BODY_LIT_TF, VAR_CONTRACT_P, STRU_WHILE, BODY_SENT, BODY_ASSIGN, BODY_SENT_P, BODY_FUN_CALL, BODY_SENT_M, STRU_FOR, FOR_VAR, STRU_DO_WHILE, STRU_IF, STRU_ELSE, STRU_IF_LINE, STRUCTURE, STRUCTURE_VAR, STRU_IF_ELSE_IN, STRU_ELSE_IN, CUERPO, FUNC_PARAM, FUNC_MOD, FUNC_RETURNS, CUERPO_M, ASSIGN_NOT_VAR, BODY_SENT_PP, CUERPO_P, EXP_P, EXP_PP, EXP_PPP, OP_EXCL, BOOL_GATE, FUNC_CALL_CASE, FUNC_CALL_CASE_P, ARIT_GATE, EXP_P_S, INICIO_S, CUERPO_MA, CUERPO_ASSIGN_F, CUERPO_ASSIGN_FP, F_EXP,F_EXP_P, F_EXP_PP, F_BODY_LIT_TF, F_ARIT_GATE, F_OP_ARIT_P, F_EXP_P_S, F_FUNC_CALL_CASE, F_OP_ARIT, F_EXP_PPP, F_FUNC_CALL_CASE_P, F_OP_ARIT_Parent, F_OP , NEGADO, OP_BOOL_N, FS_EXP,FS_EXP_P, FS_EXP_PP, FS_BODY_LIT_TF, FS_ARIT_GATE, FS_EXP_P_S, FS_EXP_PPP, FS_OP, FS_BOOL_GATE, FS_OP_BOOL_P, FS_OP_OP_BOOL, FS_OP_BOOL , PARENT_S, OP_ARIT_A, FS_OP_BOOL_F, PCLASS, RETURN_P;

precedence left porcentaje, mas_igual, por_igual, div_igual, menos_igual;
precedence nonassoc C_Parent_R;
precedence left  mas, menos;
precedence left  por, div;
// precedence left O_Parent_R;

start with INICIO_INICIO;

/*--------------------- Reglas Semanticas ---------------------------*/
// INICIO ::= pragma solidity techo numero numero punto_coma INICIO_P;

/* Si se coloca errores aquí se omiten todos los errores porsteriores*/
INICIO_INICIO ::= {:inicioArchivo();:} INICIO {:finArchivo();:};
INICIO ::= pragma solidity techo numero numero punto_coma contract ident O_Parent_L BODY_CONTRACT C_Parent_L INICIO_S ;
INICIO_S ::= contract ident O_Parent_L BODY_CONTRACT C_Parent_L INICIO_S |  ;

BODY_CONTRACT ::= EN BODY_CONTRACT | BODY_CONTRACT_P;
BODY_CONTRACT_P ::= VAR_CONTRACT BODY_CONTRACT_P | BODY_CONTRACT_PP;
BODY_CONTRACT_PP ::= STRUCTURE BODY_CONTRACT_PP | BODY_CONTRACT_PPP;
BODY_CONTRACT_PPP ::= FUNC BODY_CONTRACT_PPP | ;

/*------------------------- FUNCIONES -------------------------------*/
FUNC ::= functionSoli {:funcStart();:} ident:funcId {:recuerdaFuncId(funcId, funcIdleft);:} O_Parent_R TIPO:paramTipo {:recuerdaTipoParam(paramTipo);:} ident:paramIdent {:recuerdaIdentParam(paramIdent, paramIdentleft);:} FUNC_PARAM C_Parent_R FUNC_MOD:mod {:recuerdaFuncMod(mod);:} FUNC_RETURNS O_Parent_L CUERPO_M RETURN_P C_Parent_L:ff {:funcEnd(ffleft);:} | functionSoli error C_Parent_L; // Aqui se agrego ---------
FUNC_PARAM ::= coma TIPO:paramTipo {:recuerdaTipoParam(paramTipo);:} ident:paramIdent {:recuerdaIdentParam(paramIdent, paramIdentleft);:} FUNC_PARAM | ;
FUNC_MOD ::= payableSoli | privateSoli | publicSoli | internalSoli | ;
FUNC_RETURNS ::= returns O_Parent_R TIPO:tipoReturn {:recuerdaTipoReturn(tipoReturn);:} ident:identReturn {:recuerdaIdentReturn(identReturn, identReturnleft);:} C_Parent_R | ;
RETURN_P ::= returnSoli EXP:rf {:retornoFuncion(rfleft);:} punto_coma | ;

/*--------------------------- CUERPO --------------------------------*/
/* Revisar declaraciones con tipo en cuerpo de funcion*/
CUERPO_M ::= CUERPO_MA CUERPO_M | ;
CUERPO_MA ::= TIPO VAR_ARR VAR_ACCESS ident CUERPO_ASSIGN_F | CUERPO ;
// CUERPO ::= ident igual CUERPO_P | ident punto ident igual CUERPO_P | EXP punto_coma | O_Parent_R FUNC_CALL_PARAMS punto_coma | STRU;
CUERPO ::= ident:id {:recuerdaVariable(id, idleft);:} igual:op_ig {:recuerdaOperador(op_ig, op_igleft);:} CUERPO_P | EXP punto_coma | O_Parent_R FUNC_CALL_PARAMS punto_coma | STRU;
CUERPO_P ::= ASSIGN_NOT_VAR | STRU_IF_LINE;

/*-------------------- CUERPO ASIGNACIONES --------------------------*/
CUERPO_ASSIGN_F ::= igual CUERPO_ASSIGN_FP | punto_coma;
CUERPO_ASSIGN_FP ::= ASSIGN_NOT_VAR | STRU_IF_LINE;

/*------------------------ Estructuras ------------------------------*/
STRUCTURE ::= structSoli ident O_Parent_L TIPO VAR_ARR VAR_ACCESS ident punto_coma STRUCTURE_VAR C_Parent_L | structSoli error C_Parent_L | structSoli ident error C_Parent_L ; // aqui se agrego -----------
STRUCTURE_VAR ::= TIPO VAR_ARR VAR_ACCESS ident punto_coma STRUCTURE_VAR | ;

//---------------------------------------------------------------------------------------------------------------------------//
/*------------------- Estructuras de control ------------------------*/
STRU ::= STRU_WHILE | STRU_FOR | STRU_DO_WHILE | STRU_IF;

/*--------------------------- While ---------------------------------*/
STRU_WHILE ::= whileSoli {: startWhile(); :} O_Parent_R OP_BOOL:ev {:evalBinary(evleft);:} C_Parent_R {: testWhile(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endWhile(); :} | whileSoli  error C_Parent_L; // aqui se agrego ----------

/*---------------------------- For ----------------------------------*/
STRU_FOR ::= forSoli O_Parent_R FOR_VAR punto_coma OP_BOOL punto_coma F_EXP C_Parent_R O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L ; // aqui se agrego ----------

/*------------------------- do-while --------------------------------*/
STRU_DO_WHILE ::= doSoli O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L whileSoli O_Parent_R OP_BOOL C_Parent_R punto_coma ; // aqui se agrego ----------

/*---------------------------- if -----------------------------------*/
STRU_IF ::= ifSoli {: startIf(); :} O_Parent_R OP_BOOL:ev {:evalBinary(evright);:} C_Parent_R {: testIf(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L STRU_ELSE | ifSoli error C_Parent_L; // Aqui se agrego ----------

/*--------------------------- else ----------------------------------*/
STRU_ELSE ::= elseSoli {: startElse(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endIf(); :} | elseSoli error C_Parent_L | {: endIf(); :} ; // Aqui se agrego ---------

/*-------------------------- If line --------------------------------*/
STRU_IF_LINE ::= O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP punto_punto EXP punto_coma 
        | O_Parent_R error punto_coma 
        | O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP error punto_coma ; // en espera de poncho-----------


/*------------------------- BODY_SENT -------------------------------*////AGREGAR AQUI
BODY_SENT_M ::= BODY_SENT BODY_SENT_M | ;
BODY_SENT ::= ident:id {:recuerdaVariable(id, idleft);:} BODY_SENT_P | thisSoli punto ident igual EXP punto_coma
    | whileSoli {: startWhile(); :} O_Parent_R OP_BOOL:ev {:evalBinary(evleft);:} C_Parent_R {: testWhile(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endWhile(); :}
    | forSoli O_Parent_R FOR_VAR punto_coma OP_BOOL punto_coma F_EXP C_Parent_R O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L 
    | doSoli O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L whileSoli O_Parent_R OP_BOOL C_Parent_R punto_coma 
    | STRU_IF_ELSE_IN
    | returnSoli punto_coma 
    | breakSoli:br {:recordarBreak(br, brleft);:} punto_coma 
    | continueSoli:b {:recordarContinue(b, bleft);:} punto_coma ;

BODY_SENT_P ::= punto ident BODY_SENT_PP| BODY_SENT_PP;
BODY_SENT_PP ::= BODY_ASSIGN | BODY_FUN_CALL | igual O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP punto_punto EXP punto_coma;
STRU_IF_ELSE_IN ::= ifSoli {: startIf(); :} O_Parent_R OP_BOOL:ev {:evalBinary(evleft);:} C_Parent_R {: testIf(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L STRU_ELSE_IN ;
STRU_ELSE_IN ::= elseSoli {: startElse(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endIf(); :} | {: endIf(); :};

// BODY_WHILE ::= BODY_SENT BODY_WHILE | epsilon;
BODY_ASSIGN ::= igual:op_ig {: recuerdaOperador(op_ig, op_igleft); :} EXP punto_coma:ev {:evalBinary(evleft);:} ;
BODY_FUN_CALL ::= O_Parent_R FUNC_CALL_PARAMS C_Parent_R punto_coma ;
FOR_VAR ::= ident igual EXP ;
// IF_LINE_VAR ::= punto ident | ;

FUNC_CALL_PARAMS ::= FS_EXP FUNC_CALL_PARAMS_P | ;
FUNC_CALL_PARAMS_P ::= coma FS_EXP FUNC_CALL_PARAMS | ;
ASSIGN_NOT_VAR ::= EXP punto_coma:ev {: evalBinary(evleft); :};
//-----------------------------------------------------------------------------revisar igual sr----------------------------------------------//
/*--------------------------- ENUMS ---------------------------------*///TIENE PUNTO Y COMA
EN ::= enumSoli ident O_Parent_L ident EN_IDENT C_Parent_L | enumSoli error C_Parent_L ;  // Aque se agrego ----------------------------------------------
EN_IDENT ::= coma ident EN_IDENT | ;

/*------------------------- VARIABLES -------------------------------*///INCOMPLETA
VAR_CONTRACT ::= TIPO:inputTipo {: recuerdoTipo(inputTipo, inputTipoleft); :} VAR_ARR VAR_ACCESS:inputAccess {: recuerdoAccess(inputAccess, inputAccessleft); :} ident:b {: recuerdoID(b, bleft); :} VAR_CONTRACT_P 
                | TIPO error punto_coma ;// Aque se agrego ----------------------------------------------

/*--------------- 1.A VARIABLES sin asignacion ----------------------*/
VAR_CONTRACT_P ::= punto_coma:i {: insertarTablaSimbolos(ileft); :} 
                | VAR_CONTRACT_C punto_coma:i {: insertarTablaSimbolosAsignacion(ileft); :};

/*--------------- 1.B VARIABLES con asignacion ----------------------*/
VAR_CONTRACT_C ::= igual:op_ig {:recuerdaOperador(op_ig, op_igleft);:} EXP:ev {:evalBinary(evleft);:} ;///////////////////////Prueba

/*----------------- 1.C Estructura Variables ------------------------*/
VAR_ARR ::= O_Parent_C C_Parent_C | ;
VAR_ACCESS ::= publicSoli:b {: RESULT = b; :} 
            | privateSoli:b {: RESULT = b; :}
            | ;

/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
EXP ::= ident:id {:recuerdaVariable(id, idleft);:} EXP_P | thisSoli EXP_PP | BODY_LIT_TF | ARIT_GATE  | BOOL_GATE ;

//Operacion booleana con true o false de primero
BOOL_GATE ::= trueSoli OP_BOOL_P 
            | falseSoli OP_BOOL_P;

ARIT_GATE ::= numero:num {:recuerdaConstante(num, "constante_numerico", numleft);:} OP_ARIT_P
            | numero:num {:recuerdaConstante(num, "constante_numerico", numleft);:};


//Filto en caso id.id
EXP_P ::= punto ident EXP_P_S 
        | EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
EXP_P_S ::= O_Parent_R FUNC_CALL_CASE | OP_EXCL:op {:recuerdaOperador(op, opleft);:} PARENT_S OP_ARIT | OP_OP_BOOL OP_BOOL | ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
EXP_PP ::= punto ident EXP_PPP;
EXP_PPP ::= O_Parent_R FUNC_CALL_CASE | OP_EXCL:op {:recuerdaOperador(op, opleft);:} PARENT_S OP_ARIT | OP_OP_BOOL OP_BOOL | ;

/*--------------------- LLamadas a funciones ------------------------*/
// FUNC_CALL_CASE ::= ident FUNC_CALL_CASE_P | thisSoli punto ident FUNC_CALL_CASE_P | C_Parent_R | EXP;
FUNC_CALL_CASE ::= FS_EXP FUNC_CALL_CASE_P | C_Parent_R;
FUNC_CALL_CASE_P ::= coma FUNC_CALL_CASE | C_Parent_R ;

/*------------------- Operaciones aritmeticas -----------------------*///NO TIENE PUNTO Y COMA
OP_ARIT ::= numero:num {:recuerdaConstante(num, "constante_numerico", numleft);:} OP_ARIT_P 
            | ident:id {:recuerdaVariable(id, idleft);:} OP_ARIT_A:ev {:evalBinary(evleft);:}
            | thisSoli punto ident OP_ARIT_A 
            | numero:num {:recuerdaConstante(num, "constante_numerico", numleft); evalBinary(numleft);:};
OP_ARIT_A ::= O_Parent_R FUNC_CALL_CASE 
            | OP_ARIT_P 
            | ; // Se quito el evalBinary y se puso en la linea 1025
OP_ARIT_P ::= OP:op {:recuerdaOperador(op, opleft);:} PARENT_S OP_ARIT 
            | C_Parent_R;
// OP_ARIT_Parent ::= punto ident | ;

PARENT_S ::= C_Parent_R | O_Parent_R | ;

OP ::= mas:op_op {:RESULT = op_op;:} | menos:op_op {:RESULT = op_op;:} | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;
OP_EXCL ::= mas:op_op {:RESULT = op_op;:} | menos:op_op {:RESULT = op_op;:} | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;
// THREE ::= ident | thisSoli punto ident | numero | ;

/*-------------------- Operaciones booleanas ------------------------*///NO TIENE PUNTO Y COMA
OP_BOOL ::= NEGADO OP_BOOL_N:opop {:RESULT = opop;:};
OP_BOOL_N ::= trueSoli:bool {:recuerdaConstante(bool, "constante_booleana", boolleft);:} OP_BOOL_P:opop {:RESULT = opop;:} | falseSoli:bool{:recuerdaConstante(bool, "constante_booleana", boolleft);:} OP_BOOL_P | ident:id {: recuerdaVariable(id, idleft); :} OP_BOOL_P | numero:num {: recuerdaConstante(num, "constante_numerico", numleft); :} OP_BOOL_P;
OP_BOOL_P ::= OP_OP_BOOL:op_b {: recuerdaOperador(op_b, op_bleft); RESULT = op_b; :} OP_BOOL | ;

OP_OP_BOOL ::= igual_igual:op_bool {: RESULT=op_bool; :} | mayor_igual:op_bool {: RESULT=op_bool; :} | mayor:op_bool {: RESULT=op_bool; :} | menor_igual:op_bool {: RESULT=op_bool; :} | menor:op_bool {: RESULT=op_bool; :} | diferente:op_bool {: RESULT=op_bool; :} | op_or | op_and;

NEGADO ::= negacion | ;

/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
BODY_LIT_TF ::= numero_HEX | stringSoli;

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
F_EXP ::= ident F_EXP_P | thisSoli F_EXP_PP | F_BODY_LIT_TF | F_ARIT_GATE;

//Operacion booleana con true o false de primero
F_ARIT_GATE ::= numero F_OP_ARIT_P;

//Filto en caso id.id
F_EXP_P ::= punto ident F_EXP_P_S 
        | F_EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
F_EXP_P_S ::= O_Parent_R F_FUNC_CALL_CASE | F_OP F_OP_ARIT | igual F_OP_ARIT ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
F_EXP_PP ::= punto ident F_EXP_PPP;
F_EXP_PPP ::= O_Parent_R F_FUNC_CALL_CASE | F_OP F_OP_ARIT | ;

/*--------------------- LLamadas a funciones ------------------------*/
F_FUNC_CALL_CASE ::= ident F_FUNC_CALL_CASE_P | thisSoli punto ident F_FUNC_CALL_CASE_P | C_Parent_R;
F_FUNC_CALL_CASE_P ::= coma F_FUNC_CALL_CASE | C_Parent_R ;

/*------------------- Operaciones aritmeticas -----------------------*///NO TIENE PUNTO Y COMA
F_OP_ARIT ::= numero F_OP_ARIT_P | ident F_OP_ARIT_Parent F_OP_ARIT_P | thisSoli punto ident F_OP_ARIT_Parent F_OP_ARIT_P;
F_OP_ARIT_P ::= F_OP F_OP_ARIT | ;

F_OP_ARIT_Parent ::= punto ident | ;
F_OP ::= mas | menos | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;

/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
F_BODY_LIT_TF ::= numero_HEX | stringSoli;

//-----------------------------------------------------------------------------------
/* Esto se agrego para poder tener expresiones booleanas en las llamadas a funciones*/
//-----------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
FS_EXP ::= ident FS_EXP_P | thisSoli FS_EXP_PP | FS_BODY_LIT_TF | FS_ARIT_GATE | FS_BOOL_GATE;

//Operacion booleana con true o false de primero
FS_BOOL_GATE ::= trueSoli FS_OP_BOOL_P | falseSoli FS_OP_BOOL_P;
FS_ARIT_GATE ::= numero FS_OP_BOOL_P;

//Filto en caso id.id
FS_EXP_P ::= punto ident FS_EXP_P_S 
        | FS_EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
FS_EXP_P_S ::= O_Parent_R FS_OP_BOOL | FS_OP FS_OP_BOOL | FS_OP_OP_BOOL FS_OP_BOOL | ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
FS_EXP_PP ::= punto ident FS_EXP_PPP;
FS_EXP_PPP ::= O_Parent_R FS_OP_BOOL | FS_OP FS_OP_BOOL | FS_OP_OP_BOOL FS_OP_BOOL | ;

/*--------------------- LLamadas a funciones ------------------------*/
// FS_FUNC_CALL_CASE ::= ident FS_FUNC_CALL_CASE_P | thisSoli punto ident FS_FUNC_CALL_CASE_P | C_Parent_R;
// FS_FUNC_CALL_CASE_P ::= coma FS_FUNC_CALL_CASE | C_Parent_R ;


/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
FS_BODY_LIT_TF ::= numero_HEX | stringSoli;
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------- Operaciones booleanas ------------------------*///NO TIENE PUNTO Y COMA
FS_OP_BOOL ::= negacion FS_OP_BOOL_F | FS_OP_BOOL_F | trueSoli FS_OP_BOOL_P | falseSoli FS_OP_BOOL_P | numero FS_OP_BOOL_P;
FS_OP_BOOL_F ::= ident PCLASS FS_OP_BOOL_P | thisSoli punto ident FS_OP_BOOL_P;
FS_OP_BOOL_P ::= FS_OP_OP_BOOL FS_OP_BOOL | ;

FS_OP_OP_BOOL ::= igual_igual | mayor_igual | mayor | menor_igual | menor | diferente | op_or | op_and | mas | menos | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;

PCLASS ::= punto ident | ;

// FS_NEGADO ::= negacion | ;
//-----------------------------------------------------------------------------------
/* Fin de codigo para agregar expresiones booleanas a llamada a funiones*/
//-----------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------ TIPOS Datos ------------------------------*/
TIPO ::= bool:b {:RESULT = b;:} 
        | byteSoli:b {:RESULT = b;:}
        | bytes:b {:RESULT = b;:}
        | string:b {:RESULT = b;:}
        | uint:b {:RESULT = b;:}
        | uint_O:b {:RESULT = b;:}
        | uint_DS:b {:RESULT = b;:}
        | uint_TD:b {:RESULT = b;:}
        | uint_SC:b {:RESULT = b;:}
        | uint_CVO:b {:RESULT = b;:}
        | uint_DCS:b {:RESULT = b;:}
        | intSoli:b {:RESULT = b;:}
        | int_O:b {:RESULT = b;:}
        | int_DS:b {:RESULT = b;:}
        | int_TD:b {:RESULT = b;:}
        | int_SC:b {:RESULT = b;:}
        | int_CVO:b {:RESULT = b;:}
        | int_DCS:b {:RESULT = b;:}
        | address:b {:RESULT = b;:}
        | address_payable:b {:RESULT = b;:}
        | charss:b {:RESULT = b;:}
        | ufixedSoli:b {:RESULT = b;:}
        | B_I:b {:RESULT = b;:}
        | B_II:b {:RESULT = b;:}
        | B_III:b {:RESULT = b;:}
        | B_IV:b {:RESULT = b;:}
        | B_V:b {:RESULT = b;:}
        | B_VI:b {:RESULT = b;:}
        | B_VII:b {:RESULT = b;:}
        | B_IIX:b {:RESULT = b;:}
        | B_IX:b {:RESULT = b;:}
        | B_X:b {:RESULT = b;:}
        | B_XI:b {:RESULT = b;:}
        | B_XII:b {:RESULT = b;:}
        | B_XIII:b {:RESULT = b;:}
        | B_XIV:b {:RESULT = b;:}
        | B_XV:b {:RESULT = b;:}
        | B_XVI:b {:RESULT = b;:}
        | B_XVII:b {:RESULT = b;:}
        | B_XIIX:b {:RESULT = b;:}
        | B_XIX:b {:RESULT = b;:}
        | B_XX:b {:RESULT = b;:}
        | B_XXI:b {:RESULT = b;:}
        | B_XXII:b {:RESULT = b;:}
        | B_XXIII:b {:RESULT = b;:}
        | B_XXIV:b {:RESULT = b;:}
        | B_XXV:b {:RESULT = b;:}
        | B_XXVI:b {:RESULT = b;:}
        | B_XXVII:b {:RESULT = b;:}
        | B_XXIIX:b {:RESULT = b;:}
        | B_XXIX:b {:RESULT = b;:}
        | B_XXX:b {:RESULT = b;:}
        | B_XXXI:b {:RESULT = b;:}
        | B_XXXII:b {:RESULT = b;:};