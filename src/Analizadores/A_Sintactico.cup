package Analizadores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.io.File; // Import the File class
import java.io.FileNotFoundException; // Import this class to handle errors
import java.util.Scanner; // Import the Scanner class to read text files
import java.io.FileWriter; // Import the FileWriter class
import java.io.IOException;

parser code
{:
    public String resultado="";
    public static String nombreArchivo;
    public FileWriter myWriter;

    // lista donde se almacenan los errores sintácticos
    public static LinkedList<TError> TablaES = new LinkedList<TError>();
    public static LinkedList<Integer> listaParametros = new LinkedList<Integer>();
    public static LinkedList<RegistroSemantico> pilaSemantica = new LinkedList<RegistroSemantico>();
    public static LinkedList<Simbolo> tablaSimbolos = new LinkedList<Simbolo>();

    public void writeLine(final String pData, final int flag) throws IOException {
        if (flag == 0) {
            myWriter.write(pData + "\n");
        } else {
            myWriter.write(pData + " ");
        }
        myWriter.flush();
    }


    //Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s)
    {        
        if(s.value != null){
            String lexema = s.value.toString();
            int fila = s.left;
            int columna = s.right;
            TError datos = new TError(lexema,fila,columna,"Error Sintactico","Caracter no esperado");
            TablaES.add(datos);
            System.out.println("------ Recuperacion exitosa ------");
            System.out.println("\t\tLexema: "+lexema);
        }
    }

    //Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        if(s.value != null){
            String lexema = s.value.toString();
            int fila = s.left;
            int columna = s.right;
            TError datos = new TError(lexema,fila,columna,"Error Sintactico","Caracter no esperado");
            TablaES.add(datos);
            System.out.println("------ Error Sintactico irrecuperable ------");
            System.out.println("\t\tLexema: "+lexema);
        }
    }

    /* Metodos para realizar las acciones semánticas*/

    public void recuerdoTipo(String pTipo){
        pilaSemantica.push(new RS_Tipo(pTipo));
    }

    public void recuerdoAccess(String pAcces){
        if(pAcces != null){
            pilaSemantica.push(new RS_ACCESS(pAcces));
        }
    }

    public void recuerdoID(String pIdent){
        pilaSemantica.push(new RS_IDENT(pIdent));
    }

    public void insertarTablaSimbolos(){

        RS_IDENT id = (RS_IDENT)pilaSemantica.pop();
        RegistroSemantico sig = pilaSemantica.pop();
        SimboloVariable var = new SimboloVariable();
        if (sig.valueType == RegistroSemantico.Value.TIPO){
            RS_Tipo tipo = (RS_Tipo) sig;
            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = "public";
            var.tipoVariable = tipo.tipo;
        } else {
            RS_ACCESS acc = (RS_ACCESS) sig;
            RS_Tipo tipo = (RS_Tipo)pilaSemantica.pop();

            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = acc.access;
            var.tipoVariable = tipo.tipo;
        }
        //var.printDatos();
        // verificar si ya el id esta en la pila
        boolean estaEnTabla = false;
        for(Simbolo sim : tablaSimbolos){
            if(sim.nombre.equals(var.nombre)){
                // Variable ya esta definida dar error
                //System.out.println("Ya esta en la tabla");
                estaEnTabla = true;
            }
        }

        if(estaEnTabla){
            // Agregar el error donde corresponde
        } else {
            tablaSimbolos.push(var);
        }

    }
    public void insertarTablaSimbolosAsignacion(){

        RS_DO dop = (RS_DO)pilaSemantica.pop();
        RS_IDENT id = (RS_IDENT)pilaSemantica.pop();
        RegistroSemantico sig = pilaSemantica.pop();
        SimboloVariable var = new SimboloVariable();

        if (sig.valueType == RegistroSemantico.Value.TIPO){
            RS_Tipo tipo = (RS_Tipo) sig;
            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = "public";
            var.tipoVariable = tipo.tipo;
        } else {
            RS_ACCESS acc = (RS_ACCESS) sig;
            RS_Tipo tipo = (RS_Tipo)pilaSemantica.pop();

            var.nombre = id.ident;
            var.tipoSimbolo = "variable";
            var.acceso = acc.access;
            var.tipoVariable = tipo.tipo;
        }
        //var.printDatos();
        // verificar si ya el id esta en la pila
        boolean estaEnTabla = false;
        for(Simbolo sim : tablaSimbolos){
            if(sim.nombre.equals(var.nombre)){
                // Variable ya esta definida dar error
                //System.out.println("Ya esta en la tabla");
                estaEnTabla = true;
            }
        }

        if(estaEnTabla){
            // Agregar el error donde corresponde
        } else {
            tablaSimbolos.push(var);
        }

    }

    public void recuerdaConstante(String pConst, String pTipo){
        RS_DO dop = new RS_DO(pTipo, pConst);
        pilaSemantica.push(dop);
    }

    public void recuerdaVariable(String pConst){
        RS_DO dop = new RS_DO("variable", pConst);
        pilaSemantica.push(dop);
    }

    public void recuerdaOperador(String pOperador){
        RS_Operador op = new RS_Operador(pOperador);
        pilaSemantica.push(op);
    }

    public void evalBinary(){

        for(RegistroSemantico r : pilaSemantica){
            r.printDatos();
        }
        RS_DO do_uno = (RS_DO) pilaSemantica.pop();
        RS_Operador do_op = (RS_Operador) pilaSemantica.pop();
        // El RS siguiente se obtiene después para evitar problemas de tipo
        // en caso de que el operador se igual ya que a la izq del igual
        // viene un RS_IDENT y no un RS_DO

        if(do_op.operador.equals("=")){
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();



            // Generar un DO
            // hacer push del DO
        } else if(do_op.operador.equals("+")){
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String resultado = String.valueOf(Integer.parseInt(do_uno.valor) + Integer.parseInt(do_dos.valor));
                RS_DO newDO = new RS_DO("constante_numerico", resultado);
                pilaSemantica.push(newDO);
            }
            else{
                // generar codigo asm de la operacion
                //Crear un registro DO
            }
            // Generar un DO
            // hacer push del DO
        } else if(do_op.operador.equals("-")){
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String resultado = String.valueOf(Integer.parseInt(do_uno.valor) - Integer.parseInt(do_dos.valor));
                RS_DO newDO = new RS_DO("constante_numerico", resultado);
                pilaSemantica.push(newDO);
            }
            else{
                // generar codigo asm de la operacion
                //Crear un registro DO
            }
            // Generar un DO
            // hacer push del DO
        } else if (do_op.operador.equals("<") || do_op.operador.equals("<=") || do_op.operador.equals(">") || do_op.operador.equals(">=") || do_op.operador.equals("==") || do_op.operador.equals("!=")) {
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            if(do_uno.tipo.equals("constante_numerico") & do_dos.tipo.equals("constante_numerico")){
                String resultado = String.valueOf(Integer.parseInt(do_uno.valor) - Integer.parseInt(do_dos.valor));
                RS_DO newDO = new RS_DO("constante_numerico", resultado);
                pilaSemantica.push(newDO);
            }
            else if(do_uno.tipo.equals("variable") & do_dos.tipo.equals("constante_numerico")){
                // generar codigo asm de la operacion
                String nombreVar = do_uno.valor;
                int operando = Integer.parseInt(do_dos.valor);
                String op = do_op.operador;

                String codResta = "sub dword [";
                codResta = codResta.concat(nombreVar);
                codResta = codResta.concat("] ,");
                codResta = codResta.concat(do_dos.valor);
                try{
                    writeLine(codResta, 0);
                    String codCmp = "";
                    switch(op){
                        case "<":
                            break;
                        case "<=":
                            break;
                        case ">":
                            break;
                        case ">=":
                            break;
                        case "==":
                            break;
                        case "!=":
                            break;
                    }
                } catch(IOException e){
                    e.printStackTrace();
                }
                //Crear un registro DO
            }

        } else {
            // verificar que el tipo concuerde en ambos lados
            RS_DO do_dos = (RS_DO) pilaSemantica.pop();
            // Generar un DO
            // hacer push del DO
        }
    }

    public void startIf(){
        RS_IF new_IF = new RS_IF("Else_label:", "Exit_label:");
        pilaSemantica.push(new_IF);
    }

    public void testIf(){

    }

    public void startElse(){

    }

    public void endIf(){

    }

    public void startWhile(){

    }

    public void testWhile(){

    }

    public void endWhile(){

    }

    public void finArchivo(){
        try{
            writeLine("SECTION .bss", 0);
            for(Simbolo s : tablaSimbolos){
                
                if(s.tipoSimbolo.equals("variable")){
                    SimboloVariable var = (SimboloVariable) s;
                    writeLine(var.nombre, 1);
                    writeLine("resb", 1);
                    String tipo = var.tipoVariable;
                    switch(tipo){
                        case "int": 
                            writeLine("4", 0);
                            break;
                        case "string": 
                            writeLine("2", 0);
                            break;
                        case "uint":
                            writeLine("4", 0);
                            break;
                        case "bytes":
                            writeLine("1", 0);
                            break;
                        case "bytes1":
                            writeLine("1", 0);
                            break;
                        case "bytes2":
                            writeLine("2", 0);
                            break;
                        case "bytes3":
                            writeLine("3", 0);
                            break;

                        default:
                            break;
                    }
                }
            }
        } catch(IOException e ){
            e.printStackTrace();
        }
    }

    public void inicioArchivo(){
        System.out.println("Inicio!!!!");
    }


:}

//------> Codigo para las acciones gramaticales
action code
{:
:}

/*--------------- 2da Area: Declaraciones -----------------------*/
//------> declaracion de terminales 
terminal String pragma, solidity, techo, contract, O_Parent_L, C_Parent_L,enumSoli, punto_coma, coma, bool, byteSoli, bytes, uint, uint_O, uint_DS, uint_TD, uint_SC, uint_CVO, uint_DCS, intSoli, int_O, int_DS, int_TD, int_SC, int_CVO, int_DCS, address, address_payable, O_Parent_C, C_Parent_C, publicSoli, privateSoli, igual, trueSoli, falseSoli, igual_igual , mayor_igual , mayor , menor_igual , menor , diferente , op_or , op_and , negacion, mas , menos , div , por , O_Parent_R , C_Parent_R , porcentaje , mas_igual , menos_igual , por_igual , div_igual, punto, thisSoli, whileSoli, returnSoli, breakSoli, continueSoli, forSoli, doSoli, ifSoli, elseSoli, interrogacion_C, punto_punto, structSoli, functionSoli, payableSoli, internalSoli, returns, charss, string, ufixedSoli, ident, numero,numero_HEX,stringSoli, B_I , B_II , B_III , B_IV , B_V , B_VI , B_VII , B_IIX , B_IX , B_X , B_XI , B_XII , B_XIII , B_XIV , B_XV , B_XVI , B_XVII , B_XIIX , B_XIX , B_XX , B_XXI , B_XXII , B_XXIII , B_XXIV , B_XXV , B_XXVI , B_XXVII , B_XXIIX , B_XXIX , B_XXX , B_XXXI , B_XXXII;

//------> declaracion de no terminales
non terminal String INICIO_INICIO, INICIO, BODY_CONTRACT, BODY_CONTRACT_P, BODY_CONTRACT_PP, BODY_CONTRACT_PPP, EN, STRU, FUNC, EN_IDENT, TIPO, VAR_ARR, VAR_ACCESS, VAR_CONTRACT, VAR_CONTRACT_C, EXP, OP_ARIT, OP,OP_BOOL,OP_OP_BOOL, OP_ARIT_P, OP_BOOL_P,FUNC_CALL_PARAMS,FUNC_CALL_PARAMS_P,BODY_LIT_TF, VAR_CONTRACT_P, STRU_WHILE, BODY_SENT, BODY_ASSIGN, BODY_SENT_P, BODY_FUN_CALL, BODY_SENT_M, STRU_FOR, FOR_VAR, STRU_DO_WHILE, STRU_IF, STRU_ELSE, STRU_IF_LINE, STRUCTURE, STRUCTURE_VAR, STRU_IF_ELSE_IN, STRU_ELSE_IN, CUERPO, FUNC_PARAM, FUNC_MOD, FUNC_RETURNS, CUERPO_M, ASSIGN_NOT_VAR, BODY_SENT_PP, CUERPO_P, EXP_P, EXP_PP, EXP_PPP, OP_EXCL, BOOL_GATE, FUNC_CALL_CASE, FUNC_CALL_CASE_P, ARIT_GATE, EXP_P_S, INICIO_S, CUERPO_MA, CUERPO_ASSIGN_F, CUERPO_ASSIGN_FP, F_EXP,F_EXP_P, F_EXP_PP, F_BODY_LIT_TF, F_ARIT_GATE, F_OP_ARIT_P, F_EXP_P_S, F_FUNC_CALL_CASE, F_OP_ARIT, F_EXP_PPP, F_FUNC_CALL_CASE_P, F_OP_ARIT_Parent, F_OP , NEGADO, OP_BOOL_N, FS_EXP,FS_EXP_P, FS_EXP_PP, FS_BODY_LIT_TF, FS_ARIT_GATE, FS_EXP_P_S, FS_EXP_PPP, FS_OP, FS_BOOL_GATE, FS_OP_BOOL_P, FS_OP_OP_BOOL, FS_OP_BOOL , PARENT_S, OP_ARIT_A, FS_OP_BOOL_F, PCLASS;

precedence left porcentaje, mas_igual, por_igual, div_igual, menos_igual;
precedence nonassoc C_Parent_R;
precedence left  mas, menos;
precedence left  por, div;
// precedence left O_Parent_R;

start with INICIO_INICIO;

/*--------------------- Reglas Semanticas ---------------------------*/
// INICIO ::= pragma solidity techo numero numero punto_coma INICIO_P;

/* Si se coloca errores aquí se omiten todos los errores porsteriores*/
INICIO_INICIO ::= {:inicioArchivo();:} INICIO {:finArchivo();:};
INICIO ::= pragma solidity techo numero numero punto_coma contract ident O_Parent_L BODY_CONTRACT C_Parent_L INICIO_S ;
INICIO_S ::= contract ident O_Parent_L BODY_CONTRACT C_Parent_L INICIO_S |  ;

BODY_CONTRACT ::= EN BODY_CONTRACT | BODY_CONTRACT_P;
BODY_CONTRACT_P ::= VAR_CONTRACT BODY_CONTRACT_P | BODY_CONTRACT_PP;
BODY_CONTRACT_PP ::= STRUCTURE BODY_CONTRACT_PP | BODY_CONTRACT_PPP;
BODY_CONTRACT_PPP ::= FUNC BODY_CONTRACT_PPP | ;

/*------------------------- FUNCIONES -------------------------------*/
FUNC ::= functionSoli ident O_Parent_R TIPO ident FUNC_PARAM C_Parent_R FUNC_MOD FUNC_RETURNS O_Parent_L CUERPO_M returnSoli EXP punto_coma C_Parent_L | functionSoli error C_Parent_L; // Aqui se agrego ---------
FUNC_PARAM ::= coma TIPO ident FUNC_PARAM | ;
FUNC_MOD ::= payableSoli | privateSoli | publicSoli | internalSoli | ;
FUNC_RETURNS ::= returns O_Parent_R TIPO ident C_Parent_R | ;

/*--------------------------- CUERPO --------------------------------*/
/* Revisar declaraciones con tipo en cuerpo de funcion*/
CUERPO_M ::= CUERPO_MA CUERPO_M | ;
CUERPO_MA ::= TIPO VAR_ARR VAR_ACCESS ident CUERPO_ASSIGN_F | CUERPO ;
// CUERPO ::= ident igual CUERPO_P | ident punto ident igual CUERPO_P | EXP punto_coma | O_Parent_R FUNC_CALL_PARAMS punto_coma | STRU;
CUERPO ::= ident:id {:recuerdaVariable(id);:} igual:op_ig {:recuerdaOperador(op_ig);:} CUERPO_P | EXP punto_coma | O_Parent_R FUNC_CALL_PARAMS punto_coma | STRU;
CUERPO_P ::= ASSIGN_NOT_VAR | STRU_IF_LINE;

/*-------------------- CUERPO ASIGNACIONES --------------------------*/
CUERPO_ASSIGN_F ::= igual CUERPO_ASSIGN_FP | punto_coma;
CUERPO_ASSIGN_FP ::= ASSIGN_NOT_VAR | STRU_IF_LINE;

/*------------------------ Estructuras ------------------------------*/
STRUCTURE ::= structSoli ident O_Parent_L TIPO VAR_ARR VAR_ACCESS ident punto_coma STRUCTURE_VAR C_Parent_L | structSoli error C_Parent_L | structSoli ident error C_Parent_L ; // aqui se agrego -----------
STRUCTURE_VAR ::= TIPO VAR_ARR VAR_ACCESS ident punto_coma STRUCTURE_VAR | ;

//---------------------------------------------------------------------------------------------------------------------------//
/*------------------- Estructuras de control ------------------------*/
STRU ::= STRU_WHILE | STRU_FOR | STRU_DO_WHILE | STRU_IF;

/*--------------------------- While ---------------------------------*/
STRU_WHILE ::= whileSoli {: startWhile(); :} O_Parent_R OP_BOOL C_Parent_R {: testWhile(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endWhile(); :} | whileSoli  error C_Parent_L; // aqui se agrego ----------

/*---------------------------- For ----------------------------------*/
STRU_FOR ::= forSoli O_Parent_R FOR_VAR punto_coma OP_BOOL punto_coma F_EXP C_Parent_R O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L ; // aqui se agrego ----------

/*------------------------- do-while --------------------------------*/
STRU_DO_WHILE ::= doSoli O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L whileSoli O_Parent_R OP_BOOL C_Parent_R punto_coma ; // aqui se agrego ----------

/*---------------------------- if -----------------------------------*/
STRU_IF ::= ifSoli {: startIf(); :} O_Parent_R OP_BOOL {:evalBinary();:} C_Parent_R {: testIf(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L STRU_ELSE | ifSoli error C_Parent_L; // Aqui se agrego ----------

/*--------------------------- else ----------------------------------*/
STRU_ELSE ::= elseSoli {: startElse(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endIf(); :} | elseSoli error C_Parent_L | {: endIf(); :} ; // Aqui se agrego ---------

/*-------------------------- If line --------------------------------*/
STRU_IF_LINE ::= O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP punto_punto EXP punto_coma 
        | O_Parent_R error punto_coma 
        | O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP error punto_coma ; // en espera de poncho-----------


/*------------------------- BODY_SENT -------------------------------*////AGREGAR AQUI
BODY_SENT_M ::= BODY_SENT BODY_SENT_M | ;
BODY_SENT ::= ident:id {:recuerdaVariable(id);:} BODY_SENT_P | thisSoli punto ident igual EXP punto_coma
    | whileSoli {: startWhile(); :} O_Parent_R OP_BOOL C_Parent_R {: testWhile(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endWhile(); :}
    | forSoli O_Parent_R FOR_VAR punto_coma OP_BOOL punto_coma F_EXP C_Parent_R O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L 
    | doSoli O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L whileSoli O_Parent_R OP_BOOL C_Parent_R punto_coma 
    | STRU_IF_ELSE_IN
    | returnSoli punto_coma 
    | breakSoli punto_coma 
    | continueSoli punto_coma ;

BODY_SENT_P ::= punto ident BODY_SENT_PP| BODY_SENT_PP;
BODY_SENT_PP ::= BODY_ASSIGN | BODY_FUN_CALL | igual O_Parent_R OP_BOOL C_Parent_R interrogacion_C EXP punto_punto EXP punto_coma;
STRU_IF_ELSE_IN ::= ifSoli {: startIf(); :} O_Parent_R OP_BOOL C_Parent_R {: testIf(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L STRU_ELSE_IN ;
STRU_ELSE_IN ::= elseSoli {: startElse(); :} O_Parent_L BODY_SENT BODY_SENT_M C_Parent_L {: endIf(); :} | {: endIf(); :};

// BODY_WHILE ::= BODY_SENT BODY_WHILE | epsilon;
BODY_ASSIGN ::= igual:op_ig {: recuerdaOperador(op_ig); :} EXP punto_coma {:evalBinary();:} ;
BODY_FUN_CALL ::= O_Parent_R FUNC_CALL_PARAMS C_Parent_R punto_coma ;
FOR_VAR ::= ident igual EXP ;
// IF_LINE_VAR ::= punto ident | ;

FUNC_CALL_PARAMS ::= FS_EXP FUNC_CALL_PARAMS_P | ;
FUNC_CALL_PARAMS_P ::= coma FS_EXP FUNC_CALL_PARAMS | ;
ASSIGN_NOT_VAR ::= EXP punto_coma {: evalBinary(); :};
//-----------------------------------------------------------------------------revisar igual sr----------------------------------------------//
/*--------------------------- ENUMS ---------------------------------*///TIENE PUNTO Y COMA
EN ::= enumSoli ident O_Parent_L ident EN_IDENT C_Parent_L | enumSoli error C_Parent_L ;  // Aque se agrego ----------------------------------------------
EN_IDENT ::= coma ident EN_IDENT | ;

/*------------------------- VARIABLES -------------------------------*///INCOMPLETA
VAR_CONTRACT ::= TIPO:inputTipo {: recuerdoTipo(inputTipo); :} VAR_ARR VAR_ACCESS:inputAccess {: recuerdoAccess(inputAccess); :} ident:b {: recuerdoID(b); :} VAR_CONTRACT_P 
                | TIPO error punto_coma ;// Aque se agrego ----------------------------------------------

/*--------------- 1.A VARIABLES sin asignacion ----------------------*/
VAR_CONTRACT_P ::= punto_coma {: insertarTablaSimbolos(); :} 
                | VAR_CONTRACT_C punto_coma {: insertarTablaSimbolosAsignacion(); :};

/*--------------- 1.B VARIABLES con asignacion ----------------------*/
VAR_CONTRACT_C ::= igual:op_ig {:recuerdaOperador(op_ig);:} EXP {:evalBinary();:} ;///////////////////////Prueba

/*----------------- 1.C Estructura Variables ------------------------*/
VAR_ARR ::= O_Parent_C C_Parent_C | ;
VAR_ACCESS ::= publicSoli:b {: RESULT = b; :} 
            | privateSoli:b {: RESULT = b; :}
            | ;

/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
EXP ::= ident:id {:recuerdaVariable(id);:} EXP_P | thisSoli EXP_PP | BODY_LIT_TF | ARIT_GATE  | BOOL_GATE ;

//Operacion booleana con true o false de primero
BOOL_GATE ::= trueSoli OP_BOOL_P 
            | falseSoli OP_BOOL_P;

ARIT_GATE ::= numero:num {:recuerdaConstante(num, "constante_numerico");:} OP_ARIT_P
            | numero:num {:recuerdaConstante(num, "constante_numerico");:};


//Filto en caso id.id
EXP_P ::= punto ident EXP_P_S 
        | EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
EXP_P_S ::= O_Parent_R FUNC_CALL_CASE | OP_EXCL:op {:recuerdaOperador(op);:} PARENT_S OP_ARIT | OP_OP_BOOL OP_BOOL | ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
EXP_PP ::= punto ident EXP_PPP;
EXP_PPP ::= O_Parent_R FUNC_CALL_CASE | OP_EXCL:op {:recuerdaOperador(op);:} PARENT_S OP_ARIT | OP_OP_BOOL OP_BOOL | ;

/*--------------------- LLamadas a funciones ------------------------*/
// FUNC_CALL_CASE ::= ident FUNC_CALL_CASE_P | thisSoli punto ident FUNC_CALL_CASE_P | C_Parent_R | EXP;
FUNC_CALL_CASE ::= FS_EXP FUNC_CALL_CASE_P | C_Parent_R;
FUNC_CALL_CASE_P ::= coma FUNC_CALL_CASE | C_Parent_R ;

/*------------------- Operaciones aritmeticas -----------------------*///NO TIENE PUNTO Y COMA
OP_ARIT ::= numero:num {:recuerdaConstante(num, "constante_numerico");:} OP_ARIT_P 
            | ident:id {:recuerdaVariable(id);:} OP_ARIT_A 
            | thisSoli punto ident OP_ARIT_A 
            | numero:num {:recuerdaConstante(num, "constante_numerico"); evalBinary();:};
OP_ARIT_A ::= O_Parent_R FUNC_CALL_CASE 
            | OP_ARIT_P 
            | {:evalBinary();:};
OP_ARIT_P ::= OP:op {:recuerdaOperador(op);:} PARENT_S OP_ARIT 
            | C_Parent_R;
// OP_ARIT_Parent ::= punto ident | ;

PARENT_S ::= C_Parent_R | O_Parent_R | ;

OP ::= mas:op_op {:RESULT = op_op;:} | menos:op_op {:RESULT = op_op;:} | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;
OP_EXCL ::= mas:op_op {:RESULT = op_op;:} | menos:op_op {:RESULT = op_op;:} | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;
// THREE ::= ident | thisSoli punto ident | numero | ;

/*-------------------- Operaciones booleanas ------------------------*///NO TIENE PUNTO Y COMA
OP_BOOL ::= NEGADO OP_BOOL_N;
OP_BOOL_N ::= trueSoli:bool {:recuerdaConstante(bool, "constante_booleana");:} OP_BOOL_P | falseSoli:bool{:recuerdaConstante(bool, "constante_booleana");:} OP_BOOL_P | ident:id {: recuerdaVariable(id); :} OP_BOOL_P | numero:num {: recuerdaConstante(num, "constante_numerico"); :} OP_BOOL_P;
OP_BOOL_P ::= OP_OP_BOOL:op_b {: recuerdaOperador(op_b); :} OP_BOOL | ;

OP_OP_BOOL ::= igual_igual:op_bool {: RESULT=op_bool; :} | mayor_igual:op_bool {: RESULT=op_bool; :} | mayor:op_bool {: RESULT=op_bool; :} | menor_igual:op_bool {: RESULT=op_bool; :} | menor:op_bool {: RESULT=op_bool; :} | diferente:op_bool {: RESULT=op_bool; :} | op_or | op_and;

NEGADO ::= negacion | ;

/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
BODY_LIT_TF ::= numero_HEX | stringSoli;

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
F_EXP ::= ident F_EXP_P | thisSoli F_EXP_PP | F_BODY_LIT_TF | F_ARIT_GATE;

//Operacion booleana con true o false de primero
F_ARIT_GATE ::= numero F_OP_ARIT_P;

//Filto en caso id.id
F_EXP_P ::= punto ident F_EXP_P_S 
        | F_EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
F_EXP_P_S ::= O_Parent_R F_FUNC_CALL_CASE | F_OP F_OP_ARIT | igual F_OP_ARIT ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
F_EXP_PP ::= punto ident F_EXP_PPP;
F_EXP_PPP ::= O_Parent_R F_FUNC_CALL_CASE | F_OP F_OP_ARIT | ;

/*--------------------- LLamadas a funciones ------------------------*/
F_FUNC_CALL_CASE ::= ident F_FUNC_CALL_CASE_P | thisSoli punto ident F_FUNC_CALL_CASE_P | C_Parent_R;
F_FUNC_CALL_CASE_P ::= coma F_FUNC_CALL_CASE | C_Parent_R ;

/*------------------- Operaciones aritmeticas -----------------------*///NO TIENE PUNTO Y COMA
F_OP_ARIT ::= numero F_OP_ARIT_P | ident F_OP_ARIT_Parent F_OP_ARIT_P | thisSoli punto ident F_OP_ARIT_Parent F_OP_ARIT_P;
F_OP_ARIT_P ::= F_OP F_OP_ARIT | ;

F_OP_ARIT_Parent ::= punto ident | ;
F_OP ::= mas | menos | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;

/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
F_BODY_LIT_TF ::= numero_HEX | stringSoli;

//-----------------------------------------------------------------------------------
/* Esto se agrego para poder tener expresiones booleanas en las llamadas a funciones*/
//-----------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------ Expresiones ------------------------------*/
/*-------------------- Expresio Principal ---------------------------*/
FS_EXP ::= ident FS_EXP_P | thisSoli FS_EXP_PP | FS_BODY_LIT_TF | FS_ARIT_GATE | FS_BOOL_GATE;

//Operacion booleana con true o false de primero
FS_BOOL_GATE ::= trueSoli FS_OP_BOOL_P | falseSoli FS_OP_BOOL_P;
FS_ARIT_GATE ::= numero FS_OP_BOOL_P;

//Filto en caso id.id
FS_EXP_P ::= punto ident FS_EXP_P_S 
        | FS_EXP_P_S;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
FS_EXP_P_S ::= O_Parent_R FS_OP_BOOL | FS_OP FS_OP_BOOL | FS_OP_OP_BOOL FS_OP_BOOL | ;

//caso funcion | Caso operacion aritmetica | Caso operacion booleana
FS_EXP_PP ::= punto ident FS_EXP_PPP;
FS_EXP_PPP ::= O_Parent_R FS_OP_BOOL | FS_OP FS_OP_BOOL | FS_OP_OP_BOOL FS_OP_BOOL | ;

/*--------------------- LLamadas a funciones ------------------------*/
// FS_FUNC_CALL_CASE ::= ident FS_FUNC_CALL_CASE_P | thisSoli punto ident FS_FUNC_CALL_CASE_P | C_Parent_R;
// FS_FUNC_CALL_CASE_P ::= coma FS_FUNC_CALL_CASE | C_Parent_R ;


/*---------------------- Literales de cuerpo ------------------------*///NO TIENE PUNTO Y COMA
FS_BODY_LIT_TF ::= numero_HEX | stringSoli;
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------- Operaciones booleanas ------------------------*///NO TIENE PUNTO Y COMA
FS_OP_BOOL ::= negacion FS_OP_BOOL_F | FS_OP_BOOL_F | trueSoli FS_OP_BOOL_P | falseSoli FS_OP_BOOL_P | numero FS_OP_BOOL_P;
FS_OP_BOOL_F ::= ident PCLASS FS_OP_BOOL_P | thisSoli punto ident FS_OP_BOOL_P;
FS_OP_BOOL_P ::= FS_OP_OP_BOOL FS_OP_BOOL | ;

FS_OP_OP_BOOL ::= igual_igual | mayor_igual | mayor | menor_igual | menor | diferente | op_or | op_and | mas | menos | div | por | porcentaje | mas_igual | menos_igual | por_igual | div_igual;

PCLASS ::= punto ident | ;

// FS_NEGADO ::= negacion | ;
//-----------------------------------------------------------------------------------
/* Fin de codigo para agregar expresiones booleanas a llamada a funiones*/
//-----------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*------------------------ TIPOS Datos ------------------------------*/
TIPO ::= bool:b {:RESULT = b;:} 
        | byteSoli:b {:RESULT = b;:}
        | bytes:b {:RESULT = b;:}
        | string:b {:RESULT = b;:}
        | uint:b {:RESULT = b;:}
        | uint_O:b {:RESULT = b;:}
        | uint_DS:b {:RESULT = b;:}
        | uint_TD:b {:RESULT = b;:}
        | uint_SC:b {:RESULT = b;:}
        | uint_CVO:b {:RESULT = b;:}
        | uint_DCS:b {:RESULT = b;:}
        | intSoli:b {:RESULT = b;:}
        | int_O:b {:RESULT = b;:}
        | int_DS:b {:RESULT = b;:}
        | int_TD:b {:RESULT = b;:}
        | int_SC:b {:RESULT = b;:}
        | int_CVO:b {:RESULT = b;:}
        | int_DCS:b {:RESULT = b;:}
        | address:b {:RESULT = b;:}
        | address_payable:b {:RESULT = b;:}
        | charss:b {:RESULT = b;:}
        | ufixedSoli:b {:RESULT = b;:}
        | B_I:b {:RESULT = b;:}
        | B_II:b {:RESULT = b;:}
        | B_III:b {:RESULT = b;:}
        | B_IV:b {:RESULT = b;:}
        | B_V:b {:RESULT = b;:}
        | B_VI:b {:RESULT = b;:}
        | B_VII:b {:RESULT = b;:}
        | B_IIX:b {:RESULT = b;:}
        | B_IX:b {:RESULT = b;:}
        | B_X:b {:RESULT = b;:}
        | B_XI:b {:RESULT = b;:}
        | B_XII:b {:RESULT = b;:}
        | B_XIII:b {:RESULT = b;:}
        | B_XIV:b {:RESULT = b;:}
        | B_XV:b {:RESULT = b;:}
        | B_XVI:b {:RESULT = b;:}
        | B_XVII:b {:RESULT = b;:}
        | B_XIIX:b {:RESULT = b;:}
        | B_XIX:b {:RESULT = b;:}
        | B_XX:b {:RESULT = b;:}
        | B_XXI:b {:RESULT = b;:}
        | B_XXII:b {:RESULT = b;:}
        | B_XXIII:b {:RESULT = b;:}
        | B_XXIV:b {:RESULT = b;:}
        | B_XXV:b {:RESULT = b;:}
        | B_XXVI:b {:RESULT = b;:}
        | B_XXVII:b {:RESULT = b;:}
        | B_XXIIX:b {:RESULT = b;:}
        | B_XXIX:b {:RESULT = b;:}
        | B_XXX:b {:RESULT = b;:}
        | B_XXXI:b {:RESULT = b;:}
        | B_XXXII:b {:RESULT = b;:};